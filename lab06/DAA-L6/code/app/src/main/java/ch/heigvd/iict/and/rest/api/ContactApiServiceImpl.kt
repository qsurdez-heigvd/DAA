// Authors: REDACTED, REDACTED, Quentin Surdez
package ch.heigvd.iict.and.rest.api

import android.util.Log
import ch.heigvd.iict.and.rest.api.converters.PhoneTypeConverter
import ch.heigvd.iict.and.rest.api.dto.ContactDTO
import ch.heigvd.iict.and.rest.models.PhoneType
import com.google.gson.GsonBuilder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory

/**
 * Implementation of the ContactApiService interface that handles actual network communication.
 *
 * This class coordinates between different converter factories to handle both plain text responses
 * (like the enrollment UUID) and JSON responses (like contacts). It provides proper error handling
 * and ensures all network operations run on the IO dispatcher to prevent blocking the main thread.
 *
 * The class uses a two-layer converter factory approach:
 * 1. ScalarsConverterFactory for handling plain string responses (used in enrollment)
 * 2. GsonConverterFactory with custom type adapters for handling complex JSON objects
 *
 * Example of how the converters work together:
 * - Enrollment endpoint returns "420e384b-7082-464e-9afe-25f6e6319301" → handled by ScalarsConverterFactory
 * - Contacts endpoint returns JSON → handled by GsonConverterFactory
 *
 * @property retrofit The configured Retrofit instance for making network calls
 * @property api The created API interface implementation
 */
class ContactApiServiceImpl(
    private val retrofit: Retrofit = createRetrofit()
) : ContactApiService {
    /**
     * The API interface implementation generated by Retrofit.
     */
    private val api: ContactApi = retrofit.create(ContactApi::class.java)

    companion object {
        /**
         * Base URL for the API.
         */
        private const val BASE_URL = "https://daa.iict.ch"

        /**
         * Creates a configured Retrofit instance with appropriate converters and logging.
         *
         * The configuration includes:
         * - Logging interceptor for debugging API calls
         * - Custom Gson instance with type adapter for PhoneType
         * - Both Scalars and Gson converters for handling different response types
         */
        private fun createRetrofit(): Retrofit {
            val loggingInterceptor = HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            }

            val okHttpClient = okhttp3.OkHttpClient.Builder().addInterceptor(loggingInterceptor).build()

            val gson =
                GsonBuilder().registerTypeAdapter(PhoneType::class.java, PhoneTypeConverter()).serializeNulls().create()

            return Retrofit.Builder().baseUrl(BASE_URL).client(okHttpClient)
                .addConverterFactory(ScalarsConverterFactory.create())
                .addConverterFactory(GsonConverterFactory.create(gson)).build()
        }
    }

    /**
     * Enrolls a new user by requesting a UUID from the server.
     *
     * This operation is performed on the IO dispatcher to prevent blocking the main thread.
     * The response is a plain string UUID handled by the ScalarsConverterFactory.
     */
    override suspend fun enroll(): String {
        return withContext(Dispatchers.IO) {
            api.enroll()
        }
    }

    /**
     * Retrieves all contacts for a given UUID.
     *
     * This operation is performed on the IO dispatcher to prevent blocking the main thread.
     * The response is a JSON array that gets converted to a list of DTOs by GsonConverterFactory.
     */
    override suspend fun getAllContacts(uuid: String): List<ContactDTO> {
        return withContext(Dispatchers.IO) {
            api.getAllContacts(uuid)
        }
    }

    /**
     * Retrieves a specific contact by ID.
     *
     * @throws Exception if the response is not successful or the body is null
     */
    override suspend fun getContact(uuid: String, contactId: Long): ContactDTO {
        val response = api.getContact(uuid, contactId)
        if (!response.isSuccessful) {
            throw Exception("Failed to get contact")
        }
        return response.body()!!
    }

    /**
     * Creates a new contact on the server.
     *
     * @throws Exception if the response is not successful or the body is null
     */
    override suspend fun createContact(uuid: String, contact: ContactDTO): ContactDTO {
        return withContext(Dispatchers.IO) {
            api.createContact(uuid, contact)
        }
    }

    /**
     * Updates an existing contact on the server.
     *
     * This method requires the contact to have a valid remote_id.
     * @throws Exception if the response is not successful, the body is null, or remote_id is null
     */
    override suspend fun updateContact(uuid: String, contact: ContactDTO): ContactDTO {
        return withContext(Dispatchers.IO) {
            Log.d("ContactApiServiceImpl", "Updating contact: $contact")
            if (contact.id != null) {
                api.updateContact(uuid, contact.id, contact)
            } else {
                throw Exception("Cannot updated contact without a contact.id...")
            }
        }
    }

    /**
     * Deletes a contact from the server.
     *
     * Unlike other methods, this one doesn't return a response body as the server
     * responds with a 204 No Content status on successful deletion.
     */
    override suspend fun deleteContact(uuid: String, contactId: Long) {
        api.deleteContact(uuid, contactId)
    }
}